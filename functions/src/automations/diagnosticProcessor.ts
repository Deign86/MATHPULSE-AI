/**
 * MathPulse AI Cloud Functions - Diagnostic Processor
 *
 * Orchestrates the full workflow when a student completes the
 * mandatory diagnostic assessment.  This is the PRIMARY automation
 * entry point â€” everything else follows from it.
 *
 * Steps:
 * 1. Classify per-subject risk
 * 2. Update student profile with badges / risk data
 * 3. Identify weak topics
 * 4. Compute overall risk level
 * 5. Call FastAPI backend for ML risk prediction
 * 6. Generate personalised learning path (via FastAPI)
 * 7. Auto-generate remedial quizzes for "At Risk" subjects
 * 8. Generate teacher intervention recommendations
 * 9. Update dashboard data
 */

import * as admin from "firebase-admin";
import * as functions from "firebase-functions";
import {
  classifySubjectRisks,
  identifyWeakTopics,
  calculateOverallRisk,
  extractBadges,
  calculateAvgScore,
  SubjectScore,
  WeakTopic,
  OverallRisk,
} from "./riskAnalyzer";
import { buildRemedialQuizConfigs } from "./quizProcessor";
import { predictRisk, generateLearningPath } from "../services/backendApi";
import { createNotification } from "./notificationSender";
import {
  NOTIFICATION_TYPES,
} from "../config/constants";

// â”€â”€â”€ Payload Type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export interface DiagnosticPayload {
  studentId: string;
  results: SubjectScore[];
  gradeLevel: string;
  questionBreakdown?: Record<string, { correct: boolean }[]>;
}

// â”€â”€â”€ Main Processor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function processDiagnosticCompletion(
  payload: DiagnosticPayload,
): Promise<void> {
  const { studentId, results, gradeLevel, questionBreakdown } = payload;
  const db = admin.firestore();

  functions.logger.info("ðŸ“Š Starting diagnostic processing workflow", { studentId });

  // STEP 1: Classify per-subject risk
  const riskClassifications = classifySubjectRisks(results);
  functions.logger.info("Risk classifications calculated", {
    subjects: Object.keys(riskClassifications).length,
  });

  // STEP 2: Update student profile with badges & risk data
  const badges = extractBadges(riskClassifications);
  const atRiskSubjects = Object.entries(riskClassifications)
    .filter(([, data]) => data.status === "At Risk")
    .map(([subject]) => subject);

  // STEP 3: Identify weak topics
  const weakTopics = identifyWeakTopics(questionBreakdown);
  functions.logger.info("Weak topics identified", { count: weakTopics.length });

  // STEP 4: Compute overall risk level
  const overallRisk = calculateOverallRisk(riskClassifications);
  functions.logger.info("Overall risk level", { overallRisk });

  // Update student profile
  await db.collection("users").doc(studentId).update({
    hasTakenDiagnostic: true,
    subjectBadges: badges,
    riskClassifications,
    atRiskSubjects,
    overallRisk,
    lastRiskUpdate: admin.firestore.FieldValue.serverTimestamp(),
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  });

  // STEP 5: Call FastAPI backend for ML-powered risk prediction
  try {
    const riskPrediction = await predictRisk({
      engagementScore: 50, // Default for new student
      avgQuizScore: calculateAvgScore(results),
      attendance: 100, // Default for new student
      assignmentCompletion: 0, // New student hasn't completed anything
    });

    await db.collection("users").doc(studentId).update({
      mlRiskLevel: riskPrediction.riskLevel,
      mlRiskConfidence: riskPrediction.confidence,
    });

    functions.logger.info("ML risk prediction saved", {
      level: riskPrediction.riskLevel,
    });
  } catch (error: any) {
    functions.logger.warn("ML risk prediction failed, using rule-based only", {
      error: error.message,
    });
  }

  // STEP 6: Generate personalised learning path
  if (atRiskSubjects.length > 0) {
    try {
      const learningPathResponse = await generateLearningPath({
        weaknesses: atRiskSubjects,
        gradeLevel,
        learningStyle: "visual", // Default
      });

      await db.collection("learningPaths").doc(studentId).set({
        studentId,
        content: learningPathResponse.learningPath,
        weaknesses: atRiskSubjects,
        generatedAt: admin.firestore.FieldValue.serverTimestamp(),
        status: "active",
        autoGenerated: true,
        source: "diagnostic_automation",
      });

      functions.logger.info("âœ… Learning path generated", { studentId });
    } catch (error: any) {
      functions.logger.error("Learning path generation failed", {
        error: error.message,
      });
    }
  }

  // STEP 7: Auto-generate remedial quizzes
  if (atRiskSubjects.length > 0) {
    const quizConfigs = buildRemedialQuizConfigs(
      studentId,
      atRiskSubjects,
      overallRisk,
      gradeLevel,
    );

    const batch = db.batch();
    for (const config of quizConfigs) {
      const ref = db.collection("assignedQuizzes").doc();
      batch.set(ref, {
        ...config,
        assignedAt: admin.firestore.FieldValue.serverTimestamp(),
        dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      });
    }
    await batch.commit();

    functions.logger.info("âœ… Remedial quizzes created", {
      count: quizConfigs.length,
    });
  }

  // STEP 8: Generate teacher intervention recommendations
  if (overallRisk === "High" || overallRisk === "Medium") {
    await generateAndStoreInterventions(
      db,
      studentId,
      riskClassifications,
      weakTopics,
      overallRisk,
    );
  }

  // STEP 9: Student notification
  const notifMessage = atRiskSubjects.length > 0
    ? `Diagnostic complete â€” ${atRiskSubjects.length} subject(s) flagged At Risk: ${atRiskSubjects.join(", ")}`
    : "Diagnostic complete â€” all subjects On Track!";

  await createNotification({
    userId: studentId,
    type: NOTIFICATION_TYPES.GRADE,
    title: "Diagnostic Assessment Complete",
    message: notifMessage,
  });

  functions.logger.info("âœ… Diagnostic processing workflow complete", { studentId });
}

// â”€â”€â”€ Helper: Teacher Interventions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function generateAndStoreInterventions(
  db: admin.firestore.Firestore,
  studentId: string,
  riskClassifications: Record<string, any>,
  weakTopics: WeakTopic[],
  overallRisk: OverallRisk,
): Promise<void> {
  try {
    // Build a summary for the teacher
    const atRiskSubjects = Object.entries(riskClassifications)
      .filter(([, data]) => data.status === "At Risk")
      .map(([subject, data]) => `${subject} (${data.score}%)`)
      .join(", ");

    const topicSummary = weakTopics
      .slice(0, 5)
      .map((t) => `${t.topic} (${Math.round(t.accuracy * 100)}% accuracy)`)
      .join(", ");

    const interventionContent =
      `**Risk Level:** ${overallRisk}\n\n` +
      `**At-Risk Subjects:** ${atRiskSubjects}\n\n` +
      `**Weak Topics:** ${topicSummary || "None identified"}\n\n` +
      "**Recommended Actions:**\n" +
      "- Schedule one-on-one review session for at-risk subjects\n" +
      "- Assign additional practice problems for weak topics\n" +
      "- Monitor quiz performance over the next 2 weeks\n" +
      "- Consider peer tutoring for collaborative learning";

    await db.collection("interventions").add({
      studentId,
      content: interventionContent,
      overallRisk,
      riskClassifications,
      weakTopics,
      source: "diagnostic_automation",
      status: "pending",
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    // Notify teachers (look up assigned teacher)
    const studentDoc = await db.collection("users").doc(studentId).get();
    const studentData = studentDoc.data();
    const teacherId = studentData?.teacherId;
    const studentName = studentData?.displayName || studentData?.name || studentId;

    if (teacherId) {
      await createNotification({
        userId: teacherId,
        type: NOTIFICATION_TYPES.MESSAGE,
        title: "Student Needs Intervention",
        message: `${studentName} completed their diagnostic with ${overallRisk} risk level. Review recommended.`,
      });
    }

    functions.logger.info("âœ… Teacher interventions created", { studentId });
  } catch (error: any) {
    functions.logger.error("Intervention generation failed", {
      error: error.message,
    });
  }
}
